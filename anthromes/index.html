<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Radial Anthromes Chart</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    @font-face {
      font-family: "Pelikan";
      src: url("ABCPelikan-Regular-Trial.woff") format("woff");
    }
    body {
      margin: 0;
      font-family: "Pelikan", sans-serif;
      background: #ffff;
      color: white;
    }
    #controls {
      display: flex;
      justify-content: center;
      margin: 10px;
      gap: 20px;
    }
    svg {
      display: block;
      margin: auto;
      background: #ffff;
    }
    .legend {
      font-size: 12px;
      font-family: "Pelikan", sans-serif;
      fill: black;
    }
  </style>
</head>
<body>
<div id="controls">
  <label>View Size:
    <select id="viewMode">
      <option value="preview">Preview (1200x1200)</option>
      <option value="full" selected>Full Export (6400x6400)</option>
    </select>
  </label>
  <button id="export">Export SVG</button>
</div>
<svg id="chart"></svg>
<script>
const svg = d3.select("#chart");
const g = svg.append("g");
const fullSize = 6400, previewSize = 1200;
let currentSize = "full";

const colorMapping = {
  "Urban": "#fb5607",
  "Mixed settlements": "#ff006e",
  "Rice villages": "#b1f16e",
  "Irrigated villages": "#6eeb13",
  "Rainfed villages": "#13eb40",
  "Pastoral villages": "#13eb85",
  "Residential irrigated croplands": "#ebe013",
  "Residential rainfed croplands": "#eb9c13",
  "Populated croplands": "#eb1357",
  "Remote croplands": "#eb13e0",
  "Residential rangelands": "#13ebc9",
  "Populated rangelands": "#1385eb",
  "Remote rangelands": "#3a86ff",
  "Residential woodlands": "#AA55DA",
  "Populated woodlands": "#c77dff",
  "Remote woodlands": "#8338ec",
  "Inhabited drylands": "#5f0f40",
  "Wild woodlands": "#4717f6",
  "Wild drylands": "#eb139c",
  "Ice (uninhabited)": "#6A5ACD",
  "No land": "#2E8B57"
};

function render(size = "full") {
  const dim = size === "full" ? fullSize : previewSize;
  svg.attr("viewBox", `${-dim / 2} ${-dim / 2} ${dim} ${dim}`);
  g.selectAll("*").remove();

  const radius = dim / 2 - 100;
  const innerRadius = 2400;

  d3.csv("anthromes_counts.csv", d3.autoType).then(data => {
    const years = Array.from(new Set(data.map(d => d.year))).sort((a, b) => a - b);
    const labels = Object.keys(colorMapping);

    const dataByYear = d3.rollups(data, v => {
      const counts = {};
      v.forEach(d => counts[d.label] = d.count);
      return counts;
    }, d => d.year);

    const stacked = d3.stack()
      .keys(labels)
      .value((d, key) => d[1][key] || 0)
      (dataByYear);

    const angle = d3.scaleBand()
      .domain(years)
      .range([0, 2 * Math.PI])
      .align(0);

    const maxCount = d3.max(stacked[stacked.length - 1], d => d[1]);
    const rScale = d3.scaleLinear()
      .domain([0, maxCount])
      .range([innerRadius, radius]);

    const arc = d3.arc()
      .innerRadius(d => rScale(d[0]))
      .outerRadius(d => rScale(d[1]))
      .startAngle((d, i) => angle(years[i]))
      .endAngle((d, i) => angle(years[i]) + angle.bandwidth())
      .padRadius(innerRadius);

    const layers = g.selectAll("g.layer")
      .data(stacked)
      .join("g")
      .attr("class", "layer")
      .attr("fill", d => colorMapping[d.key] || "#ccc");

    layers.selectAll("path")
      .data(d => d)
      .join("path")
      .attr("d", arc);

    const tickCount = 6;
    const ticks = rScale.ticks(tickCount);

    const axisCircleGroup = g.append("g").attr("class", "axis-circles");
    axisCircleGroup.selectAll("circle")
      .data(ticks)
      .join("circle")
      .attr("r", rScale)
      .attr("stroke", "#0e0b16")
      .attr("fill", "none")
      .attr("stroke-dasharray", "2,2");

    const angleSteps = d3.range(0, 2 * Math.PI, (2 * Math.PI) / 8);
    ticks.forEach(t => {
      angleSteps.forEach(a => {
        g.append("text")
          .attr("x", Math.cos(a) * rScale(t))
          .attr("y", Math.sin(a) * rScale(t))
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "middle")
          .attr("font-size", 14)
          .attr("fill", "#0e0b16")
          .text(t);
      });
    });

    const yearAxis = g.append("g").attr("class", "year-axis");
    years.forEach(year => {
      const a = angle(year) + angle.bandwidth() / 2 - Math.PI / 2;
      const x1 = Math.cos(a) * (innerRadius - 6);
      const y1 = Math.sin(a) * (innerRadius - 6);
      const x2 = Math.cos(a) * (innerRadius);
      const y2 = Math.sin(a) * (innerRadius);
      yearAxis.append("line")
        .attr("x1", x1).attr("y1", y1)
        .attr("x2", x2).attr("y2", y2)
        .attr("stroke", "#0e0b16")
        .attr("stroke-width", 1);

      const lx = Math.cos(a) * (innerRadius - 18);
      const ly = Math.sin(a) * (innerRadius - 18);
      yearAxis.append("text")
        .attr("x", lx)
        .attr("y", ly)
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", 10)
        .attr("fill", "#0e0b16")
        .text(year);
    });

    const legend = svg.append("g")
      .attr("class", "legend")
      .attr("transform", `translate(${-dim / 2 + 60}, ${-dim / 2 + 60})`);

    const entries = Object.entries(colorMapping);
    entries.forEach(([label, color], i) => {
      const y = i * 20;
      legend.append("rect")
        .attr("x", 0)
        .attr("y", y)
        .attr("width", 16)
        .attr("height", 16)
        .attr("fill", color);

      legend.append("text")
        .attr("x", 22)
        .attr("y", y + 12)
        .attr("fill", "black")
        .text(label);
    });
  });
}

render();

d3.select("#viewMode").on("change", function() {
  currentSize = this.value;
  render(currentSize);
});

d3.select("#export").on("click", function() {
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(svg.node());
  const blob = new Blob([source], {type: "image/svg+xml;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = `radial_chart_${currentSize}.svg`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
});
</script>
</body>
</html>




